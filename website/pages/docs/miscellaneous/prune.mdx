import { Tabs, Tab } from 'nextra-theme-docs'

## `prune()` functions
<Tabs items={[
    <code>typia</code>, 
    <code>TypeGuardError.ts</code>, 
    <code>IValidation.ts</code>
]}>
    <Tab>
```typescript copy
export function prune<T>(input: T): T;
export function isPrune<T>(input: unknown): T | null;
export function assertPrune<T>(input: unknown): T;
export function validatePrune<T>(input: unknown): IValidation<T>;
```
    </Tab>
    <Tab>
```typescript copy
export class TypeGuardError extends Error {
    public readonly method: string;
    public readonly path: string | undefined;
    public readonly expected: string;
    public readonly value: any;
}
```
    </Tab>
    <Tab>
```typescript copy
export type IValidation<T> =
    | IValidation.ISuccess<T>
    | IValidation.IFailure;
export namespace IValidation {
    export interface ISuccess<T> {
        success: true;
        data: T;
    }
    export interface IFailure {
        success: false;
        errors: IError[];
    }
    export interface IError {
        path: string;
        expected: string;
        value: any;
    }
}
```
    </Tab>
</Tabs>

Deep prune function.

  - `typia.isPrune()`: [`typia.is<T>()`](../validators/is) + `typia.prune<T>()`
  - `typia.assertPrune()`: [`typia.assert<T>()`](../validators/assert) + `typia.prune<T>()`
  - `typia.validatePrune()`: [`typia.validate<T>()`](../validators/validate) + `typia.prune<T>()`




## Reusable functions
<Tabs items={[
    <code>typia</code>, 
    <code>TypeGuardError.ts</code>, 
    <code>IValidation.ts</code>
]}>
    <Tab>
```typescript copy
export function createPrune<T>: (input: T) => T;
export function createIsPrune<T>: (input: unknown) => T | null;
export function createAssertPrune<T>: (input: unknown) => T;
export function createValidatePrune<T>: (input: unknown) => IValidation<T>;
```
    </Tab>
    <Tab>
```typescript copy
export class TypeGuardError extends Error {
    public readonly method: string;
    public readonly path: string | undefined;
    public readonly expected: string;
    public readonly value: any;
}
```
    </Tab>
    <Tab>
```typescript copy
export type IValidation<T> =
    | IValidation.ISuccess<T>
    | IValidation.IFailure;
export namespace IValidation {
    export interface ISuccess<T> {
        success: true;
        data: T;
    }
    export interface IFailure {
        success: false;
        errors: IError[];
    }
    export interface IError {
        path: string;
        expected: string;
        value: any;
    }
}
```
    </Tab>
</Tabs>

Reusable `typia.prune()` function generators.

If you repeat to call `typia.prune<T>()` function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through `typia.createPrune<T>()` function.

Just look at the code below, then you may understand how to use it.